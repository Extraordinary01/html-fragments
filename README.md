# Фрагментация HTML

### Тестовое задание MadDevs

#### Запуск основного скрипта

Чтобы запустить основной скрипт, нужно выполнить команду `python main.py --max-len={max_len} {file_path}`. `max_len`
является не обязательным параметром и по умолчанию оно будет равно 4096. Для проверки, исходный `source.html` находится
в папке tests.

#### Реализация

В метод `split_message` поступает данные (прочитанные из файла) и максимальная длинна фрагмента. С помощью рекурсивного
метода `get_next_fragment` мы получаем следующий фрагмент и модифицированные изначальные данные. Т.е. мы удаляем
формированный фрагмент от исходного документа и дальше продолжаем формировать фрагмент из полученного модифицированного
остатка. Проходимся по всем дочерним элементам переданного источника и проверяем:
 - если это текст и при добавлении мы не достигаем максимальной длинны, значит добавляем в текущий фрагмент. Если мы
 превысим максимальную длину, то тогда мы начинаем формировать модифицированный остаток.
 - если это тег, то мы сначала получаем строковую версию тега (со всеми дочерними элементами) и проверяем на максимальную
 длину, если не проходим, то тогда проверяем блочный ли этот тег. Если это блочный тег, то добавляем открывающий этот тег
 в переменную `left_side`и закрывающий тег в `right_side`. Это нужно для формирования остаточной части, чтобы не потерять
 структуру блочного тега. Далее мы рекурсивно идем по внутренним элементам блочного тега. Если это не блочный тег, то
 начинаем формировать новую модифицированную остаточную часть. При рекурсивном вызове для детей блочного тега не
 забываем добавлять в переменную additional_length длину предыдущего закрывающего тега для правильного учёта
 максимальной длины. Потому что нельзя рекурсивно добавлять закрывающие теги за собой, иначе можем нарушить структуру
 при формировании модифицированного остатка.


### От автора

 Надеюсь смог более менее объяснить свою реализацию, но понимаю что это не лучшее разъяснение. Возможно если объяснять
 в живую и с примерами то получиться лучше.